name: v2 Sops Publish

on:
  push:
    branches:
      - "gh-action/update-workflow/INF-96991"
    paths:
      - "secrets/**"
  workflow_dispatch:

jobs:
  v1_secret_vault:
    name: "v1 Secret Injection via Sops"
    strategy:
      matrix:
        environment: [sandbox, staging, production]
      fail-fast: false
    runs-on: self-hosted-${{ matrix.environment }}
    environment: ${{ matrix.environment }} #no longer required

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Import Generic PGP Keys (Private and Public)
      - name: Import Generic PGP Keys
        run: |
          echo "Importing Generic PGP private key..."
          echo "${{ secrets.CI_PGP_PRIVATE_KEY }}" | gpg --batch --no-tty --import
          echo "Importing Generic PGP public key..."
          echo "${{ secrets.CI_PGP_PUBLIC_KEY }}" | gpg --import

      - name: Capture PGP Fingerprint
        run: |
          echo "Extracting fingerprint..."
          FINGERPRINT=$(gpg --list-secret-keys --with-colons | grep '^fpr' | head -n 1 | cut -d':' -f10)

          if [ -z "$FINGERPRINT" ]; then
            echo "Failed to extract fingerprint"
            exit 1
          fi

          echo "Fingerprint extracted: $FINGERPRINT"
          echo "FINGERPRINT=$FINGERPRINT" >> $GITHUB_ENV

      - name: Use Fingerprint in Another Step
        run: |
          echo "The captured fingerprint is $FINGERPRINT"

      # Export AGE Key
      - name: Set COMMON_AGE_KEY
        run: |
          AGE_KEY_FILE="sops-age-key.txt"
          echo "${{ secrets.COMMON_AGE_KEY }}" > "$AGE_KEY_FILE"
          echo "SOPS_AGE_KEY_FILE=$AGE_KEY_FILE" >> $GITHUB_ENV

      - name: Copy v1_sops.yaml
        run: cp -f configs/v1_sops.yaml .sops.yaml

      - name: Install sops
        run: |
          wget https://github.com/mozilla/sops/releases/download/v3.8.0/sops_3.8.0_amd64.deb
          sudo dpkg -i sops_3.8.0_amd64.deb

      - name: Get All Changed Files
        id: files
        uses: jitterbit/get-changed-files@v1

      - name: Check for Relevant Changes
        id: check_changes
        run: |
          IFS=' ' read -r -a modified_files <<< "${{ steps.files.outputs.added_modified }}"
          relevant_changes="false"
          for file in "${modified_files[@]}"; do
            if [[ $file == secrets/${{ matrix.environment }}/lending/* ]]; then
              relevant_changes="true"
              break
            fi
          done
          echo "RELEVANT_CHANGES=$relevant_changes" >> $GITHUB_ENV

      # Set environment variables based on the matrix environment
      - if: env.RELEVANT_CHANGES == 'true'
        name: Set environment variables for ${{ matrix.environment }} environment
        run: |
          case ${{ matrix.environment }} in
            sandbox)
              VAULT_ADDR="${{ secrets.SANDBOX_VAULT_ADDR }}"
              VAULT_TOKEN="${{ secrets.SANDBOX_VAULT_TOKEN }}"
              ;;
            staging)
              VAULT_ADDR="${{ secrets.STAGING_VAULT_ADDR }}"
              VAULT_TOKEN="${{ secrets.STAGING_VAULT_TOKEN }}"
              ;;
            production)
              VAULT_ADDR="${{ secrets.PRODUCTION_VAULT_ADDR }}"
              VAULT_TOKEN="${{ secrets.PRODUCTION_VAULT_TOKEN }}"
              ;;
            *)
              echo "Unsupported environment: ${{ matrix.environment }}"
              exit 1
              ;;
          esac
          echo "VAULT_ADDR=$VAULT_ADDR" >> $GITHUB_ENV
          echo "VAULT_TOKEN=$VAULT_TOKEN" >> $GITHUB_ENV

      - if: env.RELEVANT_CHANGES == 'true'
        name: Define Decrypted File Path
        run: |
          DECRYPTED_PATH="./decrypted"
          echo "DECRYPTED_PATH=$DECRYPTED_PATH" >> $GITHUB_ENV
          mkdir -p $DECRYPTED_PATH

      - if: env.RELEVANT_CHANGES == 'true'
        name: Process Secret Files
        run: |
          set -e
          IFS=' ' read -r -a modified_files <<< "${{ steps.files.outputs.added_modified }}"
          for file in "${modified_files[@]}"; do
            if [[ $(basename "$file") =~ \..+\.yaml$ ]]; then
              decrypted_file_path="${{ env.DECRYPTED_PATH }}/$(basename $file)"
              decrypted_json_path="${{ env.DECRYPTED_PATH }}/$(basename $file .yaml).json" # Path for the JSON file
              echo "Decrypting double-dot file: $file"
              sops -d --verbose $file > $decrypted_file_path

              # Debug: Check the contents of the decrypted YAML file
              echo "Decrypted YAML content:"
              cat "$decrypted_file_path"

              # Convert YAML to JSON using yq
              pip install yq
              yq -r . "$decrypted_file_path" > "$decrypted_json_path" || echo "yq conversion failed"

              # Debug: Check if the JSON file is created and list files in the directory
              echo "Listing files in decrypted path:"
              ls -lah "${{ env.DECRYPTED_PATH }}/"

              # Debug: Output the contents of the JSON file
              echo "Converted JSON content:"
              cat "$decrypted_json_path"


              # Construct and upload to Vault
              filename_without_extension="$(basename $file .yaml)"
              IFS='.' read -r secret_name sub_path <<< "$filename_without_extension"
              vault_path="secret/data/$secret_name/$sub_path"
              echo "Uploading to Vault at path: $vault_path"
              curl -H "X-Vault-Token: $VAULT_TOKEN" \
                    -H "Content-Type: application/json" \
                    --request POST \
                    --data @"$decrypted_json_path" \
                    $VAULT_ADDR/v1/$vault_path
            else
              echo "Publishing secret using sops for file: $file"
              sops publish -y $file
            fi
          done
